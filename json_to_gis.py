## © by kirill kapitonov
## moscow, 2024
## приветствуется донейшн

## нам потребуется ряд библиотек. Геопандас лучше ставится через конду (типа conda install geopandas или как-то похожим образом), но может и сработать
## pip3 install geopandas, через просто pip install geopandas может выйти ошибка. Если нет конды, достаточно установить miniconda на комп

## перед началом работы надо положить json выгрузки в папку и рядом с этой папкой (не в нее, а именно рядом) этот скрипт

import pandas as pd 
import geopandas as gpd
import matplotlib.pyplot as plt
import os, shutil

def json_cleaner(filename, json_folder): ## задаем функцию, которая будет json из 2 гиса превращать в csv

    with open(f'{json_folder}/{filename}.json', 'r') as f:
        data = f.read() ## открываем json файл и считываем его в переменную дата

    data = data.split('"items":[{')[1] ## отрезаем лишний хвост json'а 
    data = data.split('},{') ## разбиваем по скобочкам на список

    dumper = {'id':[], 'name':[], 'lat':[], 'lon':[], 'address_name':[]} ## мне нужны были именно эти 
    ## данные, можно просить и другие, хотя там особо больше ничего полезного. Если надо что-то еще, добавляешь в этот словарь нужное слово

    for x in data: ## перебираем кусочки списка, то есть отдельно взятые объекты
        for i in x.split(',"'): ## разбиваем это все на список пар "кодовое слово - атрибут", перебираем эти пары
            i = i.replace('":"', ':') ## меняем двоеточия в кавычках на просто двоеточия
            i = i.replace('"', '') ## двойные кавычки
            i = i.replace('{', '') ## фигурные скобки
            i = i.replace('}', '') ## еще фигурные скобки
            i = i.replace('point:', '') ## слово point:, внутри которого прячется пара широта-долгота

            ## теперь у нас есть строка вида "слово:атрибут", например, "name:Пятерочка"

            for j in dumper.keys(): ## проходимся по словарю кодовых слов
                if j == i.split(':')[0]: ## если ключевое слово совпадает с первым в паре
                    key_ = i.split(':')[0] ## записываем ключевое слово
                    val_ = i.split(':')[1] ## записываем значение
                    swap = dumper[key_] ## вытаскиваем, что уже было в словаре
                    swap.append(val_) # аппендим значение
                    dumper[key_] = swap # и в категорию по ключу добавляем значение

        ## NB! если в джейсоне какой-то из атрибутов, который тебе нужен у объекта не прописан, словарь получится кривой (одна из категорий короче отсальных)
        ## и все криво пропишется. Но это случается нечасто, лучше либо удалить объект, либо руками в джсон написать что-нибудь
        ## дальше немного пропущенного кода, который был нужен для поиска этой ошибки :)
                    
        # swap = dumper['geometry']
        # swap.append(f'POINT {float(dumper["lat"][-1]), float(dumper["lon"][-1])}')
        # dumper['geometry'] = swap
 
    # print(dumper)
    # print(10*'\n')
                    
    dump = pd.DataFrame(dumper) ## создаем датафрейм на основании словаря
    dump.to_csv(f'csv/{filename}.csv') ## сохраняем в цсв
    ## конец первой функции


def csv_to_gis(filename, lon, lat, format): # вторая функция создает геофайл на основе цсв

    dump = pd.read_csv(f'csv/_fin/{filename}.csv') ## читаем склеенные цсв из папки _fin

    gdf = gpd.GeoDataFrame(
    dump, geometry=gpd.points_from_xy(dump[lon], dump[lat]), crs='EPSG:4326') ## создаем точечный слой в WGS84

    gdf = gdf.to_crs(32637) ## перевотим в UTM-37N (если надо, можно поменять)

    gdf.to_file(f'gis/{filename}.{format.lower()}', driver=format) #сохраняем в gpkg или geojson
    ## конец второй функции



print(50 * '=' + 40 * '\n') ## поскольку общение с программой происходит в терминале, печатаем много пустых строк, чтобы не мешалось

os.chdir(__file__[:__file__.rfind('/'):]) ## программа смотрит полный путь к файлу на компе, и меняет рабочую папку с корневой на ту, в которой лежит скрипт

if 'csv' not in os.listdir(): # если нет папки цсв в рабочей папке
    os.mkdir('csv') # делаем папку цсв

if 'gis' not in os.listdir(): # то же самое для папки с пространственными данными
    os.mkdir('gis')

json_folder = input('json folder name: ') # вводим в переменную имя папки, где лежат json'ы (например, "json")
json = os.listdir(json_folder) ## в эту переменную пишем список имен всех файлов, которые есть в этой папке

if input('format: (G)PKG or Geo(J)son?').lower() == 'g': # узнаем, в геопекадже или геоджейсоне желает барин (я в гпкг всегда делал)
    format = 'GPKG'
else:
    format = 'GeoJSON'

for i in sorted(json): ## проходимя по списку имен файлов в папке с джейсонами
    filename = i.split('.')[0] ## отделяем расширение от имени, используем только само имя
    if '.json' in i: ## если имеем дело с json файлом (мало ли там еще в папке что окажется)
        lon = 'lon' ## пишем в lon название, под которым в джейсоне прячут lon
        lat = 'lat' ## то же самое для lat
        print(filename) ## на всякий случай печатаем имя файла, с которым ща будет работа (чтобы понимать, на каком 
        ## программа может сломаться, см. выше про ошибку при пустых атрибутах)

        json_cleaner(filename, json_folder) ## перевариваем программу в csv

        ## еще одна строка отладки 
        # csv_to_gis(filename, lon, lat, format)

csv_dir = os.listdir('csv') ## в переменную берем названия файлов из папки csv

if '_fin' not in csv_dir: ## если у нас нет папке csv паки _fin
    os.mkdir('csv/_fin') ## делаем ее
else:
    shutil.rmtree('csv/_fin') ## иначе удаляем ее
    os.mkdir('csv/_fin') ## и делаем новую пустую

## дальше идет код, который пришлось написать из-за ограничений выгрузок 2гиса в учебных целях, а именно не больше 10 вхождений в один json
## поэтому приходится выгружать по несколько файлов одного и того же запроса, например shop1, shop2 итд

for i in csv_dir: ## проходимся по списку файлов в папке csv
    _fin = os.listdir('csv/_fin') ## берем списко файлов в папке фин
    x = ''.join([a for a in i if not a.isdigit()]) ## в х берем только имя csv файла без цифр (например, shop)

    if x not in _fin and '.csv' in i: ## если шопов еще нет в папке фин, и файл при этом цсв

        # d = open(f'csv/{i}').read()

        data = pd.read_csv(f'csv/{i}') ## считываем эту цсв в датафрейм

        for j in csv_dir: ## проходимся по папке цсв еще раз

            if i != j and 'csv' in j: ## если файл не тот, который мы сейчас открыли, отрубили от него цифры и записали в дату
                y =  ''.join([a for a in j if not a.isdigit()]) ## отрубаем от него цифры
                if x == y: ## и если имена у них совпадают (то есть тоже шоп)
                    df = pd.read_csv(f'csv/{j}') ## то мы считываем его в еще один датафрейм
                    data = pd.concat([data, df], ignore_index=True) ## и приклеиваем один датафрейм к другому

        drop = data[['id', 'name', 'lat', 'lon', 'address_name']] ## потом выделяем нужные нам колонки
        drop.to_csv(f'csv/_fin/{x}') ## и дропаем все в финальную папку (теперь вместо shop1...shop15 у нас одна цсвха shop)



## transform csv to gpkg
_fin = os.listdir('csv/_fin') ## берем список файлов в финальной папке

for i in _fin: ## проходимся по нему
        if ".csv" in i: ## если цсв
            filename = i.split('.')[0] ## берем название файла
            lon = 'lon' ## задаем название колонки с долготой
            lat = 'lat' ## с широтой
            print(filename) ## печатаем пользователю, какой файл перевариваем
            csv_to_gis(filename, lon, lat, format) ## переводим его в гпкг или геоджсон и сохраняем куда надо (все прописано в функции)